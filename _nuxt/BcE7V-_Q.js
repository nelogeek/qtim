import{i as b,P as N,p as M,Q as y,R as j,S as H,m as R,s as w,T as U,U as F,V as $,h as z,W as L,X as W,Y as q,Z as G,_ as I}from"./BsKDYBO5.js";const Q={trailing:!0};function X(a,e=25,i={}){if(i={...Q,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let c,s,r=[],t,v;const u=(f,n)=>(t=Y(a,f,n),t.finally(()=>{if(t=null,i.trailing&&v&&!s){const _=u(f,v);return v=null,_}}),t);return function(...f){return t?(i.trailing&&(v=f),t):new Promise(n=>{const _=!s&&i.leading;clearTimeout(s),s=setTimeout(()=>{s=null;const g=i.leading?c:u(this,f);for(const m of r)m(g);r=[]},e),_?(c=u(this,f),n(c)):r.push(n)})}}async function Y(a,e,i){return await a.apply(e,i)}const Z=Symbol.for("nuxt:client-only"),J=a=>a==="defer"||a===!1;function x(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;K(a[0],a[1])&&a.unshift(e);let[i,c,s={}]=a;const r=b(()=>N(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=M();s.server??=!0,s.default??=A,s.getCachedData??=T,s.lazy??=!1,s.immediate??=!0,s.deep??=y.deep,s.dedupe??="cancel",s._functionName,t._asyncData[r.value];const v={cause:"initial",dedupe:s.dedupe};t._asyncData[r.value]?._init||(v.cachedData=s.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=V(t,r.value,c,s,v.cachedData));const u=t._asyncData[r.value];u._deps++;const f=()=>t._asyncData[r.value].execute(v),n=s.server!==!1&&t.payload.serverRendered;{let m=function(l){const d=t._asyncData[l];d?._deps&&(d._deps--,d._deps===0&&d?._off())};const o=W();if(o&&n&&s.immediate&&!o.sp&&(o.sp=[]),o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const l=o._nuxtOnBeforeMountCbs;q(()=>{l.forEach(d=>{d()}),l.splice(0,l.length)}),G(()=>l.splice(0,l.length))}const P=o&&(o._nuxtClientOnly||I(Z,!1));n&&t.isHydrating&&(u.error.value||u.data.value!=null)?(u.pending.value=!1,u.status.value=u.error.value?"error":"success"):o&&(!P&&t.payload.serverRendered&&t.isHydrating||s.lazy)&&s.immediate?o._nuxtOnBeforeMountCbs.push(f):s.immediate&&f();const D=L(),h=j([r,...s.watch||[]],([l],[d])=>{if((l||d)&&l!==d){const E=t._asyncData[d]?.data.value!==y.value,B=t._asyncDataPromises[d]!==void 0;d&&m(d);const O={cause:"initial",dedupe:s.dedupe};if(!t._asyncData[l]?._init){let C;d&&E?C=t._asyncData[d]?.data.value:(C=s.getCachedData(l,t,{cause:"initial"}),O.cachedData=C),t._asyncData[l]=V(t,l,c,s,C)}t._asyncData[l]._deps++,(s.immediate||E||B)&&t._asyncData[l].execute(O)}else u._execute({cause:"watch",dedupe:s.dedupe})},{flush:"sync"});D&&H(()=>{h(),m(r.value)})}const _={data:p(()=>t._asyncData[r.value]?.data),pending:p(()=>t._asyncData[r.value]?.pending),status:p(()=>t._asyncData[r.value]?.status),error:p(()=>t._asyncData[r.value]?.error),refresh:(...m)=>t._asyncData[r.value].execute(...m),execute:(...m)=>t._asyncData[r.value].execute(...m),clear:()=>S(t,r.value)},g=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>_);return Object.assign(g,_),g}function p(a){return b({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function K(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function S(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=y.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=y.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function k(a,e){const i={};for(const c of e)i[c]=a[c];return i}function V(a,e,i,c,s){a.payload._errors[e]??=y.errorValue;const r=c.getCachedData!==T,t=i,v=c.deep?R:w,u=s!=null,f=a.hook("app:data:refresh",async _=>{(!_||_.includes(e))&&await n.execute({cause:"refresh:hook"})}),n={data:v(u?s:c.default()),pending:w(!u),error:U(a.payload._errors,e),status:w("idle"),execute:(..._)=>{const[g,m=void 0]=_,o=g&&m===void 0&&typeof g=="object"?g:{};if(a._asyncDataPromises[e]){if(J(o.dedupe??c.dedupe))return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}if(o.cause==="initial"||a.isHydrating){const D="cachedData"in o?o.cachedData:c.getCachedData(e,a,{cause:o.cause??"refresh:manual"});if(D!=null)return a.payload.data[e]=n.data.value=D,n.error.value=y.errorValue,n.status.value="success",Promise.resolve(D)}n.pending.value=!0,n.status.value="pending";const P=new Promise((D,h)=>{try{D(t(a))}catch(l){h(l)}}).then(async D=>{if(P.cancelled)return a._asyncDataPromises[e];let h=D;c.transform&&(h=await c.transform(D)),c.pick&&(h=k(h,c.pick)),a.payload.data[e]=h,n.data.value=h,n.error.value=y.errorValue,n.status.value="success"}).catch(D=>{if(P.cancelled)return a._asyncDataPromises[e];n.error.value=$(D),n.data.value=z(c.default()),n.status.value="error"}).finally(()=>{P.cancelled||(n.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=P,a._asyncDataPromises[e]},_execute:X((..._)=>n.execute(..._),0,{leading:!0}),_default:c.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{f(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),r||F(()=>{a._asyncData[e]?._init||(S(a,e),n.execute=()=>Promise.resolve(),n.data.value=y.value)})}};return n}const A=()=>y.value,T=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function ea(){const a=R(8),e=R(1),{data:i}=x("posts",async()=>(await $fetch("https://6082e3545dbd2c001757abf5.mockapi.io/qtim-test-work/posts/")).map((f,n)=>({...f,image:{url:`https://picsum.photos/800/800?random=${n+1}`,title:f.image?.title??`Random image ${n+1}`}}))),c=b(()=>i.value||[]),s=b(()=>i.value?.length||0),r=b(()=>Math.ceil(s.value/a.value)),t=b(()=>{const u=(e.value-1)*a.value,f=u+a.value;return c.value.slice(u,f)});function v(u){u>=1&&u<=r.value&&(e.value=u)}return{posts:c,total:s,currentPage:e,totalPages:r,paginatedPosts:t,setPage:v}}export{ea as u};
